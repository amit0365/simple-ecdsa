{"$message_type":"diagnostic","message":"unused imports: `Keypair` and `XOnlyPublicKey`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":2224,"byte_end":2231,"line_start":68,"line_end":68,"column_start":21,"column_end":28,"is_primary":true,"text":[{"text":"    use secp256k1::{Keypair, SecretKey, XOnlyPublicKey};","highlight_start":21,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":2244,"byte_end":2258,"line_start":68,"line_end":68,"column_start":41,"column_end":55,"is_primary":true,"text":[{"text":"    use secp256k1::{Keypair, SecretKey, XOnlyPublicKey};","highlight_start":41,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":2224,"byte_end":2233,"line_start":68,"line_end":68,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"    use secp256k1::{Keypair, SecretKey, XOnlyPublicKey};","highlight_start":21,"highlight_end":30}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":2242,"byte_end":2258,"line_start":68,"line_end":68,"column_start":39,"column_end":55,"is_primary":true,"text":[{"text":"    use secp256k1::{Keypair, SecretKey, XOnlyPublicKey};","highlight_start":39,"highlight_end":55}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":2223,"byte_end":2224,"line_start":68,"line_end":68,"column_start":20,"column_end":21,"is_primary":true,"text":[{"text":"    use secp256k1::{Keypair, SecretKey, XOnlyPublicKey};","highlight_start":20,"highlight_end":21}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":2258,"byte_end":2259,"line_start":68,"line_end":68,"column_start":55,"column_end":56,"is_primary":true,"text":[{"text":"    use secp256k1::{Keypair, SecretKey, XOnlyPublicKey};","highlight_start":55,"highlight_end":56}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused imports: `Keypair` and `XOnlyPublicKey`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:68:21\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m68\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    use secp256k1::{Keypair, SecretKey, XOnlyPublicKey};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared crate or module `rand`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":2371,"byte_end":2375,"line_start":73,"line_end":73,"column_start":23,"column_end":27,"is_primary":true,"text":[{"text":"        let mut rng = rand::thread_rng();","highlight_start":23,"highlight_end":27}],"label":"use of undeclared crate or module `rand`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared crate or module `rand`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:73:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m73\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut rng = rand::thread_rng();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared crate or module `rand`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the function or associated item `new` exists for struct `SecretKey`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":2470,"byte_end":2473,"line_start":76,"line_end":76,"column_start":30,"column_end":33,"is_primary":true,"text":[{"text":"        let sk1 = SecretKey::new(&mut rng);","highlight_start":30,"highlight_end":33}],"label":"function or associated item cannot be called on `SecretKey` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/ak36/.cargo/registry/src/index.crates.io-6f17d22bba15001f/secp256k1-0.30.0/src/key.rs","byte_start":2037,"byte_end":2057,"line_start":58,"line_end":58,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub struct SecretKey([u8; constants::SECRET_KEY_SIZE]);","highlight_start":1,"highlight_end":21}],"label":"doesn't satisfy 5 bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `secp256k1::SecretKey` consider using one of the following associated functions:\nsecp256k1::SecretKey::from_slice\nsecp256k1::SecretKey::from_byte_array\nsecp256k1::SecretKey::from_keypair","code":null,"level":"note","spans":[{"file_name":"/Users/ak36/.cargo/registry/src/index.crates.io-6f17d22bba15001f/secp256k1-0.30.0/src/key.rs","byte_start":7281,"byte_end":7339,"line_start":224,"line_end":224,"column_start":5,"column_end":63,"is_primary":true,"text":[{"text":"    pub fn from_slice(data: &[u8]) -> Result<SecretKey, Error> {","highlight_start":5,"highlight_end":63}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/ak36/.cargo/registry/src/index.crates.io-6f17d22bba15001f/secp256k1-0.30.0/src/key.rs","byte_start":7783,"byte_end":7874,"line_start":240,"line_end":240,"column_start":5,"column_end":96,"is_primary":true,"text":[{"text":"    pub fn from_byte_array(data: &[u8; constants::SECRET_KEY_SIZE]) -> Result<SecretKey, Error> {","highlight_start":5,"highlight_end":96}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/ak36/.cargo/registry/src/index.crates.io-6f17d22bba15001f/secp256k1-0.30.0/src/key.rs","byte_start":8587,"byte_end":8633,"line_start":265,"line_end":265,"column_start":5,"column_end":51,"is_primary":true,"text":[{"text":"    pub fn from_keypair(keypair: &Keypair) -> Self {","highlight_start":5,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the following trait bounds were not satisfied:\n`secp256k1::SecretKey: sha2::digest::FixedOutput`\nwhich is required by `secp256k1::SecretKey: sha2::Digest`\n`secp256k1::SecretKey: std::default::Default`\nwhich is required by `secp256k1::SecretKey: sha2::Digest`\n`secp256k1::SecretKey: sha2::digest::Update`\nwhich is required by `secp256k1::SecretKey: sha2::Digest`\n`secp256k1::SecretKey: sha2::digest::HashMarker`\nwhich is required by `secp256k1::SecretKey: sha2::Digest`\n`&secp256k1::SecretKey: sha2::digest::FixedOutput`\nwhich is required by `&secp256k1::SecretKey: sha2::Digest`\n`&secp256k1::SecretKey: std::default::Default`\nwhich is required by `&secp256k1::SecretKey: sha2::Digest`\n`&secp256k1::SecretKey: sha2::digest::Update`\nwhich is required by `&secp256k1::SecretKey: sha2::Digest`\n`&secp256k1::SecretKey: sha2::digest::HashMarker`\nwhich is required by `&secp256k1::SecretKey: sha2::Digest`\n`&mut secp256k1::SecretKey: sha2::digest::FixedOutput`\nwhich is required by `&mut secp256k1::SecretKey: sha2::Digest`\n`&mut secp256k1::SecretKey: std::default::Default`\nwhich is required by `&mut secp256k1::SecretKey: sha2::Digest`\n`&mut secp256k1::SecretKey: sha2::digest::Update`\nwhich is required by `&mut secp256k1::SecretKey: sha2::Digest`\n`&mut secp256k1::SecretKey: sha2::digest::HashMarker`\nwhich is required by `&mut secp256k1::SecretKey: sha2::Digest`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the function or associated item `new` exists for struct `SecretKey`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:76:30\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let sk1 = SecretKey::new(&mut rng);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mfunction or associated item cannot be called on `SecretKey` due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/ak36/.cargo/registry/src/index.crates.io-6f17d22bba15001f/secp256k1-0.30.0/src/key.rs:58:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct SecretKey([u8; constants::SECRET_KEY_SIZE]);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mdoesn't satisfy 5 bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: if you're trying to build a new `secp256k1::SecretKey` consider using one of the following associated functions:\u001b[0m\n\u001b[0m      secp256k1::SecretKey::from_slice\u001b[0m\n\u001b[0m      secp256k1::SecretKey::from_byte_array\u001b[0m\n\u001b[0m      secp256k1::SecretKey::from_keypair\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/ak36/.cargo/registry/src/index.crates.io-6f17d22bba15001f/secp256k1-0.30.0/src/key.rs:224:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn from_slice(data: &[u8]) -> Result<SecretKey, Error> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m240\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn from_byte_array(data: &[u8; constants::SECRET_KEY_SIZE]) -> Result<SecretKey, Error> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m265\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn from_keypair(keypair: &Keypair) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `secp256k1::SecretKey: sha2::digest::FixedOutput`\u001b[0m\n\u001b[0m            which is required by `secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `secp256k1::SecretKey: std::default::Default`\u001b[0m\n\u001b[0m            which is required by `secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `secp256k1::SecretKey: sha2::digest::Update`\u001b[0m\n\u001b[0m            which is required by `secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `secp256k1::SecretKey: sha2::digest::HashMarker`\u001b[0m\n\u001b[0m            which is required by `secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&secp256k1::SecretKey: sha2::digest::FixedOutput`\u001b[0m\n\u001b[0m            which is required by `&secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&secp256k1::SecretKey: std::default::Default`\u001b[0m\n\u001b[0m            which is required by `&secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&secp256k1::SecretKey: sha2::digest::Update`\u001b[0m\n\u001b[0m            which is required by `&secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&secp256k1::SecretKey: sha2::digest::HashMarker`\u001b[0m\n\u001b[0m            which is required by `&secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&mut secp256k1::SecretKey: sha2::digest::FixedOutput`\u001b[0m\n\u001b[0m            which is required by `&mut secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&mut secp256k1::SecretKey: std::default::Default`\u001b[0m\n\u001b[0m            which is required by `&mut secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&mut secp256k1::SecretKey: sha2::digest::Update`\u001b[0m\n\u001b[0m            which is required by `&mut secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&mut secp256k1::SecretKey: sha2::digest::HashMarker`\u001b[0m\n\u001b[0m            which is required by `&mut secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the function or associated item `new` exists for struct `SecretKey`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":2514,"byte_end":2517,"line_start":77,"line_end":77,"column_start":30,"column_end":33,"is_primary":true,"text":[{"text":"        let sk2 = SecretKey::new(&mut rng);","highlight_start":30,"highlight_end":33}],"label":"function or associated item cannot be called on `SecretKey` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/ak36/.cargo/registry/src/index.crates.io-6f17d22bba15001f/secp256k1-0.30.0/src/key.rs","byte_start":2037,"byte_end":2057,"line_start":58,"line_end":58,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub struct SecretKey([u8; constants::SECRET_KEY_SIZE]);","highlight_start":1,"highlight_end":21}],"label":"doesn't satisfy 5 bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `secp256k1::SecretKey` consider using one of the following associated functions:\nsecp256k1::SecretKey::from_slice\nsecp256k1::SecretKey::from_byte_array\nsecp256k1::SecretKey::from_keypair","code":null,"level":"note","spans":[{"file_name":"/Users/ak36/.cargo/registry/src/index.crates.io-6f17d22bba15001f/secp256k1-0.30.0/src/key.rs","byte_start":7281,"byte_end":7339,"line_start":224,"line_end":224,"column_start":5,"column_end":63,"is_primary":true,"text":[{"text":"    pub fn from_slice(data: &[u8]) -> Result<SecretKey, Error> {","highlight_start":5,"highlight_end":63}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/ak36/.cargo/registry/src/index.crates.io-6f17d22bba15001f/secp256k1-0.30.0/src/key.rs","byte_start":7783,"byte_end":7874,"line_start":240,"line_end":240,"column_start":5,"column_end":96,"is_primary":true,"text":[{"text":"    pub fn from_byte_array(data: &[u8; constants::SECRET_KEY_SIZE]) -> Result<SecretKey, Error> {","highlight_start":5,"highlight_end":96}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/ak36/.cargo/registry/src/index.crates.io-6f17d22bba15001f/secp256k1-0.30.0/src/key.rs","byte_start":8587,"byte_end":8633,"line_start":265,"line_end":265,"column_start":5,"column_end":51,"is_primary":true,"text":[{"text":"    pub fn from_keypair(keypair: &Keypair) -> Self {","highlight_start":5,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the following trait bounds were not satisfied:\n`secp256k1::SecretKey: sha2::digest::FixedOutput`\nwhich is required by `secp256k1::SecretKey: sha2::Digest`\n`secp256k1::SecretKey: std::default::Default`\nwhich is required by `secp256k1::SecretKey: sha2::Digest`\n`secp256k1::SecretKey: sha2::digest::Update`\nwhich is required by `secp256k1::SecretKey: sha2::Digest`\n`secp256k1::SecretKey: sha2::digest::HashMarker`\nwhich is required by `secp256k1::SecretKey: sha2::Digest`\n`&secp256k1::SecretKey: sha2::digest::FixedOutput`\nwhich is required by `&secp256k1::SecretKey: sha2::Digest`\n`&secp256k1::SecretKey: std::default::Default`\nwhich is required by `&secp256k1::SecretKey: sha2::Digest`\n`&secp256k1::SecretKey: sha2::digest::Update`\nwhich is required by `&secp256k1::SecretKey: sha2::Digest`\n`&secp256k1::SecretKey: sha2::digest::HashMarker`\nwhich is required by `&secp256k1::SecretKey: sha2::Digest`\n`&mut secp256k1::SecretKey: sha2::digest::FixedOutput`\nwhich is required by `&mut secp256k1::SecretKey: sha2::Digest`\n`&mut secp256k1::SecretKey: std::default::Default`\nwhich is required by `&mut secp256k1::SecretKey: sha2::Digest`\n`&mut secp256k1::SecretKey: sha2::digest::Update`\nwhich is required by `&mut secp256k1::SecretKey: sha2::Digest`\n`&mut secp256k1::SecretKey: sha2::digest::HashMarker`\nwhich is required by `&mut secp256k1::SecretKey: sha2::Digest`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the function or associated item `new` exists for struct `SecretKey`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:77:30\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m77\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let sk2 = SecretKey::new(&mut rng);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mfunction or associated item cannot be called on `SecretKey` due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/ak36/.cargo/registry/src/index.crates.io-6f17d22bba15001f/secp256k1-0.30.0/src/key.rs:58:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct SecretKey([u8; constants::SECRET_KEY_SIZE]);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mdoesn't satisfy 5 bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: if you're trying to build a new `secp256k1::SecretKey` consider using one of the following associated functions:\u001b[0m\n\u001b[0m      secp256k1::SecretKey::from_slice\u001b[0m\n\u001b[0m      secp256k1::SecretKey::from_byte_array\u001b[0m\n\u001b[0m      secp256k1::SecretKey::from_keypair\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/ak36/.cargo/registry/src/index.crates.io-6f17d22bba15001f/secp256k1-0.30.0/src/key.rs:224:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn from_slice(data: &[u8]) -> Result<SecretKey, Error> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m240\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn from_byte_array(data: &[u8; constants::SECRET_KEY_SIZE]) -> Result<SecretKey, Error> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m265\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn from_keypair(keypair: &Keypair) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `secp256k1::SecretKey: sha2::digest::FixedOutput`\u001b[0m\n\u001b[0m            which is required by `secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `secp256k1::SecretKey: std::default::Default`\u001b[0m\n\u001b[0m            which is required by `secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `secp256k1::SecretKey: sha2::digest::Update`\u001b[0m\n\u001b[0m            which is required by `secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `secp256k1::SecretKey: sha2::digest::HashMarker`\u001b[0m\n\u001b[0m            which is required by `secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&secp256k1::SecretKey: sha2::digest::FixedOutput`\u001b[0m\n\u001b[0m            which is required by `&secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&secp256k1::SecretKey: std::default::Default`\u001b[0m\n\u001b[0m            which is required by `&secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&secp256k1::SecretKey: sha2::digest::Update`\u001b[0m\n\u001b[0m            which is required by `&secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&secp256k1::SecretKey: sha2::digest::HashMarker`\u001b[0m\n\u001b[0m            which is required by `&secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&mut secp256k1::SecretKey: sha2::digest::FixedOutput`\u001b[0m\n\u001b[0m            which is required by `&mut secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&mut secp256k1::SecretKey: std::default::Default`\u001b[0m\n\u001b[0m            which is required by `&mut secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&mut secp256k1::SecretKey: sha2::digest::Update`\u001b[0m\n\u001b[0m            which is required by `&mut secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&mut secp256k1::SecretKey: sha2::digest::HashMarker`\u001b[0m\n\u001b[0m            which is required by `&mut secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the function or associated item `new` exists for struct `SecretKey`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":2558,"byte_end":2561,"line_start":78,"line_end":78,"column_start":30,"column_end":33,"is_primary":true,"text":[{"text":"        let sk3 = SecretKey::new(&mut rng);","highlight_start":30,"highlight_end":33}],"label":"function or associated item cannot be called on `SecretKey` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/ak36/.cargo/registry/src/index.crates.io-6f17d22bba15001f/secp256k1-0.30.0/src/key.rs","byte_start":2037,"byte_end":2057,"line_start":58,"line_end":58,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub struct SecretKey([u8; constants::SECRET_KEY_SIZE]);","highlight_start":1,"highlight_end":21}],"label":"doesn't satisfy 5 bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `secp256k1::SecretKey` consider using one of the following associated functions:\nsecp256k1::SecretKey::from_slice\nsecp256k1::SecretKey::from_byte_array\nsecp256k1::SecretKey::from_keypair","code":null,"level":"note","spans":[{"file_name":"/Users/ak36/.cargo/registry/src/index.crates.io-6f17d22bba15001f/secp256k1-0.30.0/src/key.rs","byte_start":7281,"byte_end":7339,"line_start":224,"line_end":224,"column_start":5,"column_end":63,"is_primary":true,"text":[{"text":"    pub fn from_slice(data: &[u8]) -> Result<SecretKey, Error> {","highlight_start":5,"highlight_end":63}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/ak36/.cargo/registry/src/index.crates.io-6f17d22bba15001f/secp256k1-0.30.0/src/key.rs","byte_start":7783,"byte_end":7874,"line_start":240,"line_end":240,"column_start":5,"column_end":96,"is_primary":true,"text":[{"text":"    pub fn from_byte_array(data: &[u8; constants::SECRET_KEY_SIZE]) -> Result<SecretKey, Error> {","highlight_start":5,"highlight_end":96}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/ak36/.cargo/registry/src/index.crates.io-6f17d22bba15001f/secp256k1-0.30.0/src/key.rs","byte_start":8587,"byte_end":8633,"line_start":265,"line_end":265,"column_start":5,"column_end":51,"is_primary":true,"text":[{"text":"    pub fn from_keypair(keypair: &Keypair) -> Self {","highlight_start":5,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the following trait bounds were not satisfied:\n`secp256k1::SecretKey: sha2::digest::FixedOutput`\nwhich is required by `secp256k1::SecretKey: sha2::Digest`\n`secp256k1::SecretKey: std::default::Default`\nwhich is required by `secp256k1::SecretKey: sha2::Digest`\n`secp256k1::SecretKey: sha2::digest::Update`\nwhich is required by `secp256k1::SecretKey: sha2::Digest`\n`secp256k1::SecretKey: sha2::digest::HashMarker`\nwhich is required by `secp256k1::SecretKey: sha2::Digest`\n`&secp256k1::SecretKey: sha2::digest::FixedOutput`\nwhich is required by `&secp256k1::SecretKey: sha2::Digest`\n`&secp256k1::SecretKey: std::default::Default`\nwhich is required by `&secp256k1::SecretKey: sha2::Digest`\n`&secp256k1::SecretKey: sha2::digest::Update`\nwhich is required by `&secp256k1::SecretKey: sha2::Digest`\n`&secp256k1::SecretKey: sha2::digest::HashMarker`\nwhich is required by `&secp256k1::SecretKey: sha2::Digest`\n`&mut secp256k1::SecretKey: sha2::digest::FixedOutput`\nwhich is required by `&mut secp256k1::SecretKey: sha2::Digest`\n`&mut secp256k1::SecretKey: std::default::Default`\nwhich is required by `&mut secp256k1::SecretKey: sha2::Digest`\n`&mut secp256k1::SecretKey: sha2::digest::Update`\nwhich is required by `&mut secp256k1::SecretKey: sha2::Digest`\n`&mut secp256k1::SecretKey: sha2::digest::HashMarker`\nwhich is required by `&mut secp256k1::SecretKey: sha2::Digest`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the function or associated item `new` exists for struct `SecretKey`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:78:30\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m78\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let sk3 = SecretKey::new(&mut rng);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mfunction or associated item cannot be called on `SecretKey` due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/ak36/.cargo/registry/src/index.crates.io-6f17d22bba15001f/secp256k1-0.30.0/src/key.rs:58:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct SecretKey([u8; constants::SECRET_KEY_SIZE]);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mdoesn't satisfy 5 bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: if you're trying to build a new `secp256k1::SecretKey` consider using one of the following associated functions:\u001b[0m\n\u001b[0m      secp256k1::SecretKey::from_slice\u001b[0m\n\u001b[0m      secp256k1::SecretKey::from_byte_array\u001b[0m\n\u001b[0m      secp256k1::SecretKey::from_keypair\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/ak36/.cargo/registry/src/index.crates.io-6f17d22bba15001f/secp256k1-0.30.0/src/key.rs:224:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn from_slice(data: &[u8]) -> Result<SecretKey, Error> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m240\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn from_byte_array(data: &[u8; constants::SECRET_KEY_SIZE]) -> Result<SecretKey, Error> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m265\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn from_keypair(keypair: &Keypair) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `secp256k1::SecretKey: sha2::digest::FixedOutput`\u001b[0m\n\u001b[0m            which is required by `secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `secp256k1::SecretKey: std::default::Default`\u001b[0m\n\u001b[0m            which is required by `secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `secp256k1::SecretKey: sha2::digest::Update`\u001b[0m\n\u001b[0m            which is required by `secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `secp256k1::SecretKey: sha2::digest::HashMarker`\u001b[0m\n\u001b[0m            which is required by `secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&secp256k1::SecretKey: sha2::digest::FixedOutput`\u001b[0m\n\u001b[0m            which is required by `&secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&secp256k1::SecretKey: std::default::Default`\u001b[0m\n\u001b[0m            which is required by `&secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&secp256k1::SecretKey: sha2::digest::Update`\u001b[0m\n\u001b[0m            which is required by `&secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&secp256k1::SecretKey: sha2::digest::HashMarker`\u001b[0m\n\u001b[0m            which is required by `&secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&mut secp256k1::SecretKey: sha2::digest::FixedOutput`\u001b[0m\n\u001b[0m            which is required by `&mut secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&mut secp256k1::SecretKey: std::default::Default`\u001b[0m\n\u001b[0m            which is required by `&mut secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&mut secp256k1::SecretKey: sha2::digest::Update`\u001b[0m\n\u001b[0m            which is required by `&mut secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\u001b[0m            `&mut secp256k1::SecretKey: sha2::digest::HashMarker`\u001b[0m\n\u001b[0m            which is required by `&mut secp256k1::SecretKey: sha2::Digest`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated associated function `secp256k1::Message::from_slice`: use from_digest instead","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":2923,"byte_end":2933,"line_start":89,"line_end":89,"column_start":28,"column_end":38,"is_primary":true,"text":[{"text":"        let msg = Message::from_slice(&hash).unwrap();","highlight_start":28,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(deprecated)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: use of deprecated associated function `secp256k1::Message::from_slice`: use from_digest instead\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:89:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m89\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let msg = Message::from_slice(&hash).unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(deprecated)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 4 previous errors; 2 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 4 previous errors; 2 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0433, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0433, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0433`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0433`.\u001b[0m\n"}
